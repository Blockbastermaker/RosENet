#!usr/bin/env python

from __future__ import print_function

import os
import sqlite3

import optparse 
from rosetta.protocols.scoring import Interface
from rosetta import *
from pyrosetta import *
import pdb
from pathlib2 import Path

init('-in:auto_setup_metals')


def compute_atom_pair_energy(pdb_filename,  ligand_params, interface_cutoff = 8.0):
    pose = Pose()
    if type(ligand_params) is str:
        ligand_params = [ligand_params]
    ligand_params = Vector1(ligand_params)
    res_set = pose.conformation().modifiable_residue_type_set_for_conf()
    res_set.read_files_for_base_residue_types( ligand_params )
    pose.conformation().reset_residue_type_set_for_conf( res_set )

    pose_from_file(pose, pdb_filename)
    scorefxn = create_score_function('ref2015')
    pose_score = scorefxn(pose)

    #detect interface
    fold_tree = pose.fold_tree()
    for jump in range(1, pose.num_jump()+1):
        name = pose.residue(fold_tree.downstream_jump_residue(jump)).name()
        if name == 'pdb_INH':
            break
    interface = Interface(jump)
    interface.distance(interface_cutoff)
    interface.calculate(pose)

    energies = {}
    for rnum1 in range(1, pose.total_residue() + 1):
        if interface.is_interface(rnum1):
            r1 = pose.residue(rnum1)
            for a1 in range(1, len(r1.atoms()) + 1):
                key1 = str(rnum1) + '-' + r1.atom_name(a1).strip()
                for rnum2 in range(rnum1+1, pose.total_residue() + 1):
                    if interface.is_interface(rnum2):
                        r2 = pose.residue(rnum2)
                        for a2 in range(1, len(r2.atoms())+1):
                            key2 = str(rnum2) + '-' + r2.atom_name(a2).strip()
                            key = key1 + '-' + key2
                            ee = etable_atom_pair_energies(r1, a1, r2, a2, scorefxn)
                            pdb.set_trace()
                            if all(e == 0.0 for e in ee):
                                continue
                            energies[(key1,key2)] = ee
    en = np.array(energies.items())
    return en

def get_radii_and_charges(pdb_filename, ligand_params):
    charges = {}
    lj_radii = {}
    pose = Pose()
    if type(ligand_params) is str:
        ligand_params = [ligand_params]
    ligand_params = Vector1(ligand_params)
    res_set = pose.conformation().modifiable_residue_type_set_for_conf()
    res_set.read_files_for_base_residue_types( ligand_params )
    pose.conformation().reset_residue_type_set_for_conf( res_set )

    pose_from_file(pose, pdb_filename)
    
    for rnum1 in range(1, pose.total_residue() + 1):
        r1 = pose.residue(rnum1)
        atoms = range(1, len(r1.atoms()) + 1)
        for a1 in range(1, len(r1.atoms()) + 1):
            key1 = str(rnum1) + '-' + r1.atom_name(a1).strip()
            charges[key1] = r1.atomic_charge(a1)
            lj_radii[key1] = r1.atom_type(a1).lj_radius()
    ch = np.array(charges.items())
    rd = np.array(lj_radii.items())
    return ch, rd

def export_energies(energies, filename):
    """Export energies to sql database
    This function will 
    """
    try:
        conn = sqlite3.connect(filename)
    except:
        print("Error while connecting to the database " + filename)
        return -1
    cursor =  conn.cursor()
    tn = 'energy'
    r1 = 'residue1'
    r2 = 'residue2'
    a1 = 'atom1'
    a2 = 'atom2'
    fa_atr = 'fa_atr'
    fa_rep = 'fa_rep'
    fa_sol = 'fa_sol'
    fa_elec = 'fa_elec'
    cursor.execute("DROP TABLE IF EXISTS {tn}".format(tn = tn))
    cursor.execute("CREATE TABLE {tn} ({r1} text, {a1} text, {r2} text, {a2} text, {fa_atr} real, {fa_rep} real, {fa_sol} real, {fa_elec} real)"
            .format(tn =  tn, r1 = r1, a1 = a1, r2 = r2, a2 = a2, fa_atr = fa_atr, fa_rep = fa_rep, fa_sol = fa_sol, fa_elec = fa_elec))

    for key in energies.keys():
        r1,a1,r2,a2 = key.split('-')
        fa_atr,fa_rep,fa_sol,fa_elec = energies[key]
        cursor.execute("INSERT INTO energy(residue1, atom1, residue2, atom2, fa_atr, fa_rep, fa_sol, fa_elec) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                (r1, a1, r2, a2, fa_atr, fa_rep, fa_sol, fa_elec))

    conn.commit()
    conn.close()

def export_charges(charges, filename):
    """Export energies to sql database
    This function will 
    """
    try:
        conn = sqlite3.connect(filename)
    except:
        print("Error while connecting to the database " + filename)
        return -1
    cursor =  conn.cursor()
    tn = 'charges'
    r1 = 'residue1'
    a1 = 'atom1'
    charge = 'atomic_charge'
    cursor.execute("DROP TABLE IF EXISTS {tn}".format(tn = tn))
    cursor.execute("CREATE TABLE {tn} ({r1} text, {a1} text, {charge} real)"
            .format(tn = tn, r1 = r1, a1 = a1, charge = charge))

    for key in charges.keys():
        r1,a1 = key.split('-')
        charge = charges[key]
        cursor.execute("INSERT INTO charges(residue1, atom1, atomic_charge) VALUES (?, ?, ?)", (r1, a1, charge))

    conn.commit()
    conn.close()

def export_radii(radii, filename):
    """Export energies to sql database
    This function will 
    """
    try:
        conn = sqlite3.connect(filename)
    except:
        print("Error while connecting to the database " + filename)
        return -1
    cursor =  conn.cursor()
    tn = 'lj_radius'
    r1 = 'residue1'
    a1 = 'atom1'
    radius = 'lj_radius'
    cursor.execute("DROP TABLE IF EXISTS {tn}".format(tn = tn))
    cursor.execute("CREATE TABLE {tn} ({r1} text, {a1} text, {radius} real)"
            .format(tn = tn, r1 = r1, a1 = a1, radius = radius))

    for key in radii.keys():
        r1,a1 = key.split('-')
        radius = radii[key]
        cursor.execute("INSERT INTO lj_radius(residue1, atom1, lj_radius) VALUES (?, ?, ?)", (r1, a1, radius))

    conn.commit()
    conn.close()

def extract_and_save_energies(folder, pdb_name):
    
    os.chdir(folder)
    for i in range(1,11):
        j = folder.split('/')[-1]
        pdb_filename = pdb_name + '_complex_'+ j +'_' + "%04d" %(i) + '.pdb'
        if not os.path.isfile(pdb_filename):
            continue
        ligand_params = ['../../INH.params']
        energies = compute_atom_pair_energy(pdb_filename,  ligand_params)
        charges,radii = get_radii_and_charges(pdb_filename,  ligand_params)
        filename = pdb_name + '_charges_%04d'%(i) + '.db'
        export_charges(charges, filename)
        filename = pdb_name + '_radii_%04d'%(i) + '.db'
        export_radii(radii, filename)
        filename = pdb_name + '_energies_%04d'%(i) + '.db'
        export_energies(energies, filename)

def extract_data(pdb_name, folder):
    pdb_id, _, pdb_local_id = pdb_name.split('_', maxsplit=2)
    pdb_file = folder / pdb_name.with_suffix('.pdb')
    energies_file = folder / '{pdb_id}_charges_{pdb_local_id}.pkl'.format(pdb_id,pdb_local_id)
    charges_file = folder / '{pdb_id}_charges_{pdb_local_id}.pkl'.format(pdb_id, pdb_local_id)
    radii_file = folder / '{pdb_id}_charges_{pdb_local_id}.pkl'.format(pdb_id, pdb_local_id)

    energies = compute_atom_pair_energy(pdb_file, ligand_params)
    charges, radii = get_radii_and_charges(pdb_file, ligand_params)

    np.save(energies_file, energies)
    np.save(charges_file, charges)
    np.save(radii_file, radii)

def extract_best(folder):
    score_file = folder / 'score.sc'
    if not score_file.exists():
        return -1
    score_csv = pandas.read_csv(str(score_file), skiprows=[0],delim_whitespace=True)
    idx = score_csv.total_score.idxmin()
    extract_data(score_csv.description[idx], folder)

def extract_all(folder):
    for pdb_file in folder.glob('*_complex_*.pdb'):
        extract_data(pdb_file.stem, folder)

def save_radii_charges(folder, pdb_name):
    os.chdir(folder)
    for i in range(1,11):
        j = folder.split('/')[-1]
        pdb_filename = pdb_name + '_complex_'+ j +'_' + "%04d" %(i) + '.pdb'
        if not os.path.isfile(pdb_filename):
            continue
        ligand_params = ['../../INH.params']
        charges,radii = get_radii_and_charges(pdb_filename,  ligand_params)
        filename = pdb_name + '_charges_%04d'%(i) + '.db'
        export_charges(charges, filename)
        filename = pdb_name + '_radii_%04d'%(i) + '.db'
        export_radii(radii, filename)

if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.add_option('--pdb_name', dest = 'pdb_name')
    parser.add_option('--root_folder', dest = 'root')
    (options,args) = parser.parse_args()

    pdb_name = options.pdb_name
    root = Path(options.root) 
    extract_best(root)


